#include <stdio.h>
extern "C" {
#include <libavcodec/avcodec.h>
#include <libswscale/swscale.h>
#include <libavutil/pixdesc.h>
}
#include <opencv2/opencv.hpp>

int main() {
    FILE* fp = fopen(".test/2.h264", "rb");
    size_t size;
    void* data;
    fseek(fp, 0, SEEK_END);
    size = (size_t) ftell(fp);
    fseek(fp, 0, SEEK_SET);
    data = malloc(size);
    if (!data) {
        printf("Failed to allocate memory\n");
        fclose(fp);
        return 1;
    }
    if (fread(data, 1, size, fp) != size) {
        printf("Failed to read file\n");
        free(data);
        fclose(fp);
        return 1;
    }
    fclose(fp);


    AVPacket* packet;
    AVFrame *decoded_frame;
    AVCodec* codec;
    AVCodecContext* avcontext;
    const AVPixFmtDescriptor* desc;
    uint8_t* frame_buf;
    int bytes_per_pixel;
    int cv_linesize[1];
    SwsContext* swscontext;
    int res;

    packet = av_packet_alloc();
    if (!packet) {
        printf("Failed to allocate packet\n");
        return 1;
    }
    packet->data = (uint8_t*) data;
    packet->size = (int) size;

    decoded_frame = av_frame_alloc();
    if (!decoded_frame) {
        printf("Failed to allocate frame\n");
        return 1;
    }

    codec = avcodec_find_decoder(AV_CODEC_ID_H264);
    if (!codec){
        printf("Could not found codec by given id");
        return 1;
    }

    avcontext = avcodec_alloc_context3(codec);
    if (!avcontext){
        printf("Could not allocate avcodec context");
        return 1;
    }

    res = avcodec_open2(avcontext, codec, NULL);
    if (res < 0){
        printf("Could not initialize avcodec context");
        return 1;
    }

    res = avcodec_send_packet(avcontext, packet);
    if (res < 0) {
        printf("Error sending packet");
        return 1;
    }

    res = avcodec_receive_frame(avcontext, decoded_frame);
    if (res < 0) {
        printf("Error decoding frame");
        return 1;
    }

    desc = av_pix_fmt_desc_get(AV_PIX_FMT_RGB24);
    if (!desc){
        printf("Can't get descriptor for pixel format");
        return false;
    }
    bytes_per_pixel = av_get_bits_per_pixel(desc) / 8;
    if (!(bytes_per_pixel==3 && !(av_get_bits_per_pixel(desc) % 8))){
        printf("Unhandled bits per pixel, bad in pix fmt");
        return false;
    }
    cv_linesize[0] = bytes_per_pixel * decoded_frame->width;

    frame_buf = (uint8_t*) malloc(bytes_per_pixel * decoded_frame->width * decoded_frame->height);
    if (!frame_buf){
        printf("Failed to allocate frame buffer\n");
        return 1;
    }

    swscontext = sws_getContext(
        decoded_frame->width, decoded_frame->height, (AVPixelFormat)decoded_frame->format,
        decoded_frame->width, decoded_frame->height, AV_PIX_FMT_BGR24,
        SWS_BILINEAR, NULL, NULL, NULL
    );
    if (!swscontext){
        printf("Failed to create sws context\n");
        return 1;
    }

    res = sws_scale(
        swscontext,
        decoded_frame->data, decoded_frame->linesize, 0, decoded_frame->height,
        &frame_buf, cv_linesize
    );
    if (res != decoded_frame->height){
        printf("Failed to scale frame\n");
        return 1;
    }

    cv::Mat frame(decoded_frame->height, decoded_frame->width, CV_8UC3, frame_buf);
    cv::imshow("Decoded Frame", frame);
    cv::waitKey(0);

    av_packet_free(&packet);
    av_frame_free(&decoded_frame);
    avcodec_free_context(&avcontext);
    sws_freeContext(swscontext);
    free(frame_buf);

    free(data);

    return 0;
}
